package blacklist

import (
	"bytes"
	"io/ioutil"
	"net/url"
	"strings"
)

type Malwaredomains struct {
	Blacklist
	domains map[string]*MalwareDomain
}

type MalwareDomain struct {
	Domain string
	Type   string
	Ref    string
}

func (bl *Malwaredomains) Name() (name string) {
	return "malwaredomains"
}

func (bl *Malwaredomains) Init(cacheDir string) (err error) {
	bl.domains = make(map[string]*MalwareDomain)

	domainsTxtFile, err := CacheGet(cacheDir, "http://mirror1.malwaredomains.com/files/domains.txt", 24)
	if err != nil {
		return err
	}

	b, _ := ioutil.ReadFile(domainsTxtFile)
	lines := bytes.Split(b, []byte("\n"))
	for _, line := range lines {
		if bytes.HasPrefix(line, []byte("#")) || len(line) == 0 {
			continue
		}

		f := bytes.Split(line, []byte("\t"))
		if len(f) < 5 {
			continue
		}
		fDomain := string(bytes.ToLower(f[2]))
		fType := string(f[3])
		fRef := string(f[4])

		bl.domains[fDomain] = &MalwareDomain{fDomain, fType, fRef}
	}

	return nil
}

func (bl *Malwaredomains) Check(urls []string) (hits []Hit) {
	for _, rawurl := range urls {
		url, err := url.Parse(rawurl)
		if err != nil {
			continue
		}

		host := strings.ToLower(url.Host)
		subs := strings.Split(host, ".")
		if len(subs) < 2 {
			continue
		}
		base := strings.Join(subs[len(subs)-2:], ".")
		subs = subs[:len(subs)-1]
		subs = subs[:len(subs)-1]
		subs = append(subs, base)

		for i, _ := range subs {
			d := strings.Join(subs[i:len(subs)], ".")

			md, ok := bl.domains[d]
			if ok {
				hit := Hit{bl.Name(), rawurl, md.Domain, md.Type, md.Ref}
				hits = append(hits, hit)
			}
		}
	}

	return hits
}
