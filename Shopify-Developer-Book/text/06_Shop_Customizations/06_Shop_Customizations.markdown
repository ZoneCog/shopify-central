## Shop Customizations ##

Here are some examples of Shopify customizations that have stood the test of time. They underline the flexibility of the Shopify platform.

For example, a merchant launched his shop and was met with initial success. In fact, so many orders came in that the merchant was up against a wall with the shop administration interface. He had one thousand orders that were all paid up and needed to be fulfilled. Those orders were from a short period of time, under a week. He wanted to know how to convert the task of individually fulfilling one thousand orders (which was totally stressing out his wife, who was further stressing him out) into a single click. 

Turns out, you can use the Shopify API to inject a link into the Orders Overview screen. So, an app was quickly built that would respond to a click-and-fulfill all the selected orders. His wife was no doubt pleased to be relieved of the burden of thousand-click order fulfillment sessions.

Fulfilling orders in bulk is one small but handy use for the Shopify API. Speaking of one thousand orders, the Shopify API has limits on how much any one app can use in a short period of time. An app has to stay within its limits. Currently, that limit is that an app can make 500 API calls in 300 seconds. If an app fulfilled 250 orders and then a second request came in requesting 250 more orders, followed shortly thereafter with another 250 orders, the API limits would certainly be exceeded. The app would be blocked from using the API. The important task a developer has to think of is ensuring that these limits do not cause problems for merchants.

### Using Delayed Jobs to Manage API Limits ###

Early attempts to work within the API limits resulted in code that would sleep for 300 seconds when the API limit was reached. This turned out to be awkward for many reasons. Keeping track of the number of app operations that are completed without failure, and the number of API calls used, is prone to error. A better solution is to set up a delayed job and process API operations in the background. This turns out to be true of most apps. You never want to lock up the user interface of an app, while doing ten seconds or thirty or more of processing. That is not acceptable. Any created delayed jobs are run by a cheap worker process that just waits around for jobs. Each API call to Shopify either succeeds or fails. If it fails because the API limits have been reached, the delayed job can react to this exception and spawn a new delayed job,in the future, with the remaining work. Using this technique, it is possible to process as many API calls as needed without limit problems and without slow locked up interfaces. It's a very elegant and robust system proven to work well by hundreds of thousands of successful API calls. Shopify itself performs all of the inventory import and export operations using delayed jobs.

Back to our example, the merchant has solved the fulfillment issue and has now turned to other special issues. For example, his store products are perishable and they always get delivered on a Monday or Tuesday. When ordering the products, customers wanted to order products for more than one week and were comfortable paying for an entire month of products. Shopify does not currently support recurring orders or a subscription service. So, the solution was to provide a quantity field for the product in the cart for each week a person wanted the product. A person could order one, two, three or up to four weeks of products and pay just once for all the deliveries. By recording the delivery dates and quantities of each ordered product, it is possible to know exactly how many products get delivered per week per customer. Some customers order two or more per week so this had an immediate positive impact on the bottom line. There is even a button providing up to 3 months worth of future dates. With tweaks like this, watching a merchant nail 15% higher in sales is rewarding.

### Using Cart Attributes and WebHooks Together ###

Using a WebHook to capture paid orders, an app can be used to inspect the line items and the cart attributes for quantities and dates per product. Setting up a small data structure to record the dates and quantities means the merchant can generate a nice Excel style grid of weekly deliveries, with the ability to plan ahead. Once that step proved successful and many thousands of orders were being booked, it turned out that the ability to automatically fulfill orders using the API was crucial. The reason was that since you could fulfill an order as many times as you wanted, an order that delivered in the future could be fulfilled *each* time a delivery comes up. When you use the API to fulfill an already fulfilled but still open order, the Shipping Confirmation email alerts the customer that their delivery is on the way. Only when all deliveries are completed is an order closed. At that point, it can even be removed from the app.

### Adding Upsells to Boost Sales ###

At this point, the merchant's shop was running smoothly and booking many thousands of orders per week. The merchant wanted to add a new feature to the shop. He wanted to *upsell* special products with the existing products. 

For example, when Valentine's Day rolls around, it would be nice to offer a box of chocolates as an additional product. By creating a new product in Shopify and setting its type to *upsell*, the shop could offer this special product alongside its regular products. The app also allows the shop to assign any products of type **upsell** to regular products. Using Liquid, if the regular product has been assigned any **upsell** products, we can render them as well. By presenting upsell products, the shop was able to sell a huge amount of additional products per order. Upsells were an immediate hit. Using the API to customize the operation of a shop can really boost sales. One particular day saw an upsell convert on 1449 of 1450 carts. That is pretty impressive.

The pattern of upsells eventually moved back into a pure Shopify solution. Collections were created to hold the products of type upsell. Using a special _product.upsell.liquid_ template when rendering products, it became possible to sell all the products in the collection with one 'add to cart' button. This improvement did away with a lot of AJAX code, complexity and demonstrated that shops can truly go through periods of experimentation and evolution, while still recording sales.  

### Adding SMS Notifications ###

With so many people using smartphones and SMS services, it made sense to add this to the shop fulfillment operations. Emails can sometimes be blocked by corporate firewalls and can be less reliable. The app sends an SMS to each customer when their order is fulfilled. It was also easy enough to add a form to the shop's *Thank You* page asking the customer if they wanted to receive an SMS when their order is fulfilled. Remarkably, a huge number of people have provided their SMS numbers.

This kind of customization illustrates that you can use the Shopify platform with confidence in knowing that it can handle the twists that get thrown into the typical mix of customer-driven business cases and scenarios. 

Other recent surprising experiences came from integrating Shopify with the well-known Salesforce CRM system. It turns out that when you subscribe to Salesforce and want to send orders, they do not process the Shopify WebHook XML properly. So, a quick bridge was built by deploying an app to the cloud to accept WebHooks from Shopify. Then the app forwards the order to Salesforce, using XML formatted for Salesforce. Apps as a Proxy! Additionally, Salesforce comes with some pretty severe limits on what you can do with an entry level plan. Sometimes, it turns out that you can do better with an app running in the cloud. Bridging Shopify to an app and Salesforce has shown itself to be a pretty powerful but cost effective system as well. Shopify is soon to release an approved SalesForce app that will likely appeal to the CRM crowd.

